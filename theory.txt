# C String Theory Notes

---

## 1️⃣ Character Arrays vs Pointers

char words[100][50]; // Stores up to 100 words, each of length 49

### Example 1: Modifiable string array
char name[] = "Ahad";
name[0] = 'M'; // Now becomes "Mhad"

- Stored as: 'A' 'h' 'a' 'd' '\0'
- The null character \0 tells C where the string ends.

### Example 2: Pointer to string literal
char *name = "Ahad";

- Cannot modify the string literal. Attempting to do so is undefined behavior.

---

## 2️⃣ Reading Strings

fgets(name, sizeof(name), stdin);

- Automatically adds \0 at the end.
- Includes the newline character \n if there is space in the buffer.

Example:
Input: "aba"
Stored as: 'a' 'b' 'a' '\n' '\0'

- To remove trailing newline:
src[strcspn(src, "\n")] = '\0';

---

## 3️⃣ Working with Strings (<string.h>)

char s[] = "Ahad";

Function reference:

- strlen(s)     → Returns 4 (excludes \0)
- sizeof(s)     → Returns 5 (includes \0)
- strcpy(dest, src) → Copies src into dest
- strcat(dest, src) → Concatenates strings ("Hello" + " World" → "Hello World")
- strcmp(a, b)  → Compares lexicographically: 0 if equal, positive if a > b, negative if a < b
- strchr(s, ch) → Returns pointer to first occurrence of ch in s
- strtok(str, delimiter) → Tokenizes a string; returns pointer to next token or NULL if done

Example using strtok:

token = strtok(str, " ");   // First token
token = strtok(NULL, " ");  // Subsequent tokens; continues from last position

- Note: strtok modifies the original string by replacing delimiters with \0

---

These notes summarize core string operations in C and common pitfalls when working with character arrays and pointers.
